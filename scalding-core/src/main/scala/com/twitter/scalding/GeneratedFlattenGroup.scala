// following were autogenerated by ./codegen/flatten_group_generator.rb at Thu Nov 20 22:11:41 -0800 2014 do not edit
package com.twitter.scalding

import com.twitter.scalding.typed.KeyedListLike

object FlattenGroup {
  val pairOfNones = (None, None)

  class FlattenLeftJoin3[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C](nested: KLL[KEY, ((A, B), C)]) {
    def flattenGrouped: KLL[KEY, (A, B, C)] = 
      nested.mapValues { tup =>
        val ((a, b), c) = tup
        (a, b, c)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C](nested: KLL[KEY, ((A, B), C)]) = new FlattenLeftJoin3(nested)

  class FlattenLeftJoin4[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D](nested: KLL[KEY, (((A, B), C), D)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D)] = 
      nested.mapValues { tup =>
        val (((a, b), c), d) = tup
        (a, b, c, d)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D](nested: KLL[KEY, (((A, B), C), D)]) = new FlattenLeftJoin4(nested)

  class FlattenLeftJoin5[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E](nested: KLL[KEY, ((((A, B), C), D), E)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E)] = 
      nested.mapValues { tup =>
        val ((((a, b), c), d), e) = tup
        (a, b, c, d, e)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E](nested: KLL[KEY, ((((A, B), C), D), E)]) = new FlattenLeftJoin5(nested)

  class FlattenLeftJoin6[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F](nested: KLL[KEY, (((((A, B), C), D), E), F)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F)] = 
      nested.mapValues { tup =>
        val (((((a, b), c), d), e), f) = tup
        (a, b, c, d, e, f)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F](nested: KLL[KEY, (((((A, B), C), D), E), F)]) = new FlattenLeftJoin6(nested)

  class FlattenLeftJoin7[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G](nested: KLL[KEY, ((((((A, B), C), D), E), F), G)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G)] = 
      nested.mapValues { tup =>
        val ((((((a, b), c), d), e), f), g) = tup
        (a, b, c, d, e, f, g)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G](nested: KLL[KEY, ((((((A, B), C), D), E), F), G)]) = new FlattenLeftJoin7(nested)

  class FlattenLeftJoin8[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H](nested: KLL[KEY, (((((((A, B), C), D), E), F), G), H)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H)] = 
      nested.mapValues { tup =>
        val (((((((a, b), c), d), e), f), g), h) = tup
        (a, b, c, d, e, f, g, h)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H](nested: KLL[KEY, (((((((A, B), C), D), E), F), G), H)]) = new FlattenLeftJoin8(nested)

  class FlattenLeftJoin9[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I](nested: KLL[KEY, ((((((((A, B), C), D), E), F), G), H), I)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I)] = 
      nested.mapValues { tup =>
        val ((((((((a, b), c), d), e), f), g), h), i) = tup
        (a, b, c, d, e, f, g, h, i)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I](nested: KLL[KEY, ((((((((A, B), C), D), E), F), G), H), I)]) = new FlattenLeftJoin9(nested)

  class FlattenLeftJoin10[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J](nested: KLL[KEY, (((((((((A, B), C), D), E), F), G), H), I), J)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J)] = 
      nested.mapValues { tup =>
        val (((((((((a, b), c), d), e), f), g), h), i), j) = tup
        (a, b, c, d, e, f, g, h, i, j)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J](nested: KLL[KEY, (((((((((A, B), C), D), E), F), G), H), I), J)]) = new FlattenLeftJoin10(nested)

  class FlattenLeftJoin11[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K](nested: KLL[KEY, ((((((((((A, B), C), D), E), F), G), H), I), J), K)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K)] = 
      nested.mapValues { tup =>
        val ((((((((((a, b), c), d), e), f), g), h), i), j), k) = tup
        (a, b, c, d, e, f, g, h, i, j, k)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K](nested: KLL[KEY, ((((((((((A, B), C), D), E), F), G), H), I), J), K)]) = new FlattenLeftJoin11(nested)

  class FlattenLeftJoin12[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L](nested: KLL[KEY, (((((((((((A, B), C), D), E), F), G), H), I), J), K), L)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L)] = 
      nested.mapValues { tup =>
        val (((((((((((a, b), c), d), e), f), g), h), i), j), k), l) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L](nested: KLL[KEY, (((((((((((A, B), C), D), E), F), G), H), I), J), K), L)]) = new FlattenLeftJoin12(nested)

  class FlattenLeftJoin13[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M](nested: KLL[KEY, ((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M)] = 
      nested.mapValues { tup =>
        val ((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M](nested: KLL[KEY, ((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M)]) = new FlattenLeftJoin13(nested)

  class FlattenLeftJoin14[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: KLL[KEY, (((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N)] = 
      nested.mapValues { tup =>
        val (((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: KLL[KEY, (((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N)]) = new FlattenLeftJoin14(nested)

  class FlattenLeftJoin15[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: KLL[KEY, ((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] = 
      nested.mapValues { tup =>
        val ((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: KLL[KEY, ((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O)]) = new FlattenLeftJoin15(nested)

  class FlattenLeftJoin16[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: KLL[KEY, (((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] = 
      nested.mapValues { tup =>
        val (((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: KLL[KEY, (((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P)]) = new FlattenLeftJoin16(nested)

  class FlattenLeftJoin17[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: KLL[KEY, ((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] = 
      nested.mapValues { tup =>
        val ((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: KLL[KEY, ((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q)]) = new FlattenLeftJoin17(nested)

  class FlattenLeftJoin18[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: KLL[KEY, (((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] = 
      nested.mapValues { tup =>
        val (((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: KLL[KEY, (((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R)]) = new FlattenLeftJoin18(nested)

  class FlattenLeftJoin19[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: KLL[KEY, ((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] = 
      nested.mapValues { tup =>
        val ((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: KLL[KEY, ((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S)]) = new FlattenLeftJoin19(nested)

  class FlattenLeftJoin20[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: KLL[KEY, (((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] = 
      nested.mapValues { tup =>
        val (((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: KLL[KEY, (((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T)]) = new FlattenLeftJoin20(nested)

  class FlattenLeftJoin21[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: KLL[KEY, ((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] = 
      nested.mapValues { tup =>
        val ((((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t), u) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: KLL[KEY, ((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U)]) = new FlattenLeftJoin21(nested)

  class FlattenLeftJoin22[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: KLL[KEY, (((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U), V)]) {
    def flattenGrouped: KLL[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] = 
      nested.mapValues { tup =>
        val (((((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t), u), v) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
      }
  }

  implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: KLL[KEY, (((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U), V)]) = new FlattenLeftJoin22(nested)

  class FlattenOuterJoin3[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C](nested: KLL[KEY, (Option[(Option[A], Option[B])], Option[C])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C])] = 
      nested.mapValues { tup =>
        val (rest1, c) = tup
        val (a, b) = rest1.getOrElse(pairOfNones)
        (a, b, c)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C](nested: KLL[KEY, (Option[(Option[A], Option[B])], Option[C])]) = new FlattenOuterJoin3(nested)

  class FlattenOuterJoin4[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D](nested: KLL[KEY, (Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D])] = 
      nested.mapValues { tup =>
        val (rest1, d) = tup
        val (rest2, c) = rest1.getOrElse(pairOfNones)
        val (a, b) = rest2.getOrElse(pairOfNones)
        (a, b, c, d)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D](nested: KLL[KEY, (Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])]) = new FlattenOuterJoin4(nested)

  class FlattenOuterJoin5[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E](nested: KLL[KEY, (Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E])] = 
      nested.mapValues { tup =>
        val (rest1, e) = tup
        val (rest2, d) = rest1.getOrElse(pairOfNones)
        val (rest3, c) = rest2.getOrElse(pairOfNones)
        val (a, b) = rest3.getOrElse(pairOfNones)
        (a, b, c, d, e)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E](nested: KLL[KEY, (Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])]) = new FlattenOuterJoin5(nested)

  class FlattenOuterJoin6[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F])] = 
      nested.mapValues { tup =>
        val (rest1, f) = tup
        val (rest2, e) = rest1.getOrElse(pairOfNones)
        val (rest3, d) = rest2.getOrElse(pairOfNones)
        val (rest4, c) = rest3.getOrElse(pairOfNones)
        val (a, b) = rest4.getOrElse(pairOfNones)
        (a, b, c, d, e, f)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])]) = new FlattenOuterJoin6(nested)

  class FlattenOuterJoin7[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G])] = 
      nested.mapValues { tup =>
        val (rest1, g) = tup
        val (rest2, f) = rest1.getOrElse(pairOfNones)
        val (rest3, e) = rest2.getOrElse(pairOfNones)
        val (rest4, d) = rest3.getOrElse(pairOfNones)
        val (rest5, c) = rest4.getOrElse(pairOfNones)
        val (a, b) = rest5.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])]) = new FlattenOuterJoin7(nested)

  class FlattenOuterJoin8[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H])] = 
      nested.mapValues { tup =>
        val (rest1, h) = tup
        val (rest2, g) = rest1.getOrElse(pairOfNones)
        val (rest3, f) = rest2.getOrElse(pairOfNones)
        val (rest4, e) = rest3.getOrElse(pairOfNones)
        val (rest5, d) = rest4.getOrElse(pairOfNones)
        val (rest6, c) = rest5.getOrElse(pairOfNones)
        val (a, b) = rest6.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])]) = new FlattenOuterJoin8(nested)

  class FlattenOuterJoin9[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I])] = 
      nested.mapValues { tup =>
        val (rest1, i) = tup
        val (rest2, h) = rest1.getOrElse(pairOfNones)
        val (rest3, g) = rest2.getOrElse(pairOfNones)
        val (rest4, f) = rest3.getOrElse(pairOfNones)
        val (rest5, e) = rest4.getOrElse(pairOfNones)
        val (rest6, d) = rest5.getOrElse(pairOfNones)
        val (rest7, c) = rest6.getOrElse(pairOfNones)
        val (a, b) = rest7.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])]) = new FlattenOuterJoin9(nested)

  class FlattenOuterJoin10[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J])] = 
      nested.mapValues { tup =>
        val (rest1, j) = tup
        val (rest2, i) = rest1.getOrElse(pairOfNones)
        val (rest3, h) = rest2.getOrElse(pairOfNones)
        val (rest4, g) = rest3.getOrElse(pairOfNones)
        val (rest5, f) = rest4.getOrElse(pairOfNones)
        val (rest6, e) = rest5.getOrElse(pairOfNones)
        val (rest7, d) = rest6.getOrElse(pairOfNones)
        val (rest8, c) = rest7.getOrElse(pairOfNones)
        val (a, b) = rest8.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])]) = new FlattenOuterJoin10(nested)

  class FlattenOuterJoin11[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K])] = 
      nested.mapValues { tup =>
        val (rest1, k) = tup
        val (rest2, j) = rest1.getOrElse(pairOfNones)
        val (rest3, i) = rest2.getOrElse(pairOfNones)
        val (rest4, h) = rest3.getOrElse(pairOfNones)
        val (rest5, g) = rest4.getOrElse(pairOfNones)
        val (rest6, f) = rest5.getOrElse(pairOfNones)
        val (rest7, e) = rest6.getOrElse(pairOfNones)
        val (rest8, d) = rest7.getOrElse(pairOfNones)
        val (rest9, c) = rest8.getOrElse(pairOfNones)
        val (a, b) = rest9.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])]) = new FlattenOuterJoin11(nested)

  class FlattenOuterJoin12[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L])] = 
      nested.mapValues { tup =>
        val (rest1, l) = tup
        val (rest2, k) = rest1.getOrElse(pairOfNones)
        val (rest3, j) = rest2.getOrElse(pairOfNones)
        val (rest4, i) = rest3.getOrElse(pairOfNones)
        val (rest5, h) = rest4.getOrElse(pairOfNones)
        val (rest6, g) = rest5.getOrElse(pairOfNones)
        val (rest7, f) = rest6.getOrElse(pairOfNones)
        val (rest8, e) = rest7.getOrElse(pairOfNones)
        val (rest9, d) = rest8.getOrElse(pairOfNones)
        val (rest10, c) = rest9.getOrElse(pairOfNones)
        val (a, b) = rest10.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])]) = new FlattenOuterJoin12(nested)

  class FlattenOuterJoin13[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M])] = 
      nested.mapValues { tup =>
        val (rest1, m) = tup
        val (rest2, l) = rest1.getOrElse(pairOfNones)
        val (rest3, k) = rest2.getOrElse(pairOfNones)
        val (rest4, j) = rest3.getOrElse(pairOfNones)
        val (rest5, i) = rest4.getOrElse(pairOfNones)
        val (rest6, h) = rest5.getOrElse(pairOfNones)
        val (rest7, g) = rest6.getOrElse(pairOfNones)
        val (rest8, f) = rest7.getOrElse(pairOfNones)
        val (rest9, e) = rest8.getOrElse(pairOfNones)
        val (rest10, d) = rest9.getOrElse(pairOfNones)
        val (rest11, c) = rest10.getOrElse(pairOfNones)
        val (a, b) = rest11.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])]) = new FlattenOuterJoin13(nested)

  class FlattenOuterJoin14[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N])] = 
      nested.mapValues { tup =>
        val (rest1, n) = tup
        val (rest2, m) = rest1.getOrElse(pairOfNones)
        val (rest3, l) = rest2.getOrElse(pairOfNones)
        val (rest4, k) = rest3.getOrElse(pairOfNones)
        val (rest5, j) = rest4.getOrElse(pairOfNones)
        val (rest6, i) = rest5.getOrElse(pairOfNones)
        val (rest7, h) = rest6.getOrElse(pairOfNones)
        val (rest8, g) = rest7.getOrElse(pairOfNones)
        val (rest9, f) = rest8.getOrElse(pairOfNones)
        val (rest10, e) = rest9.getOrElse(pairOfNones)
        val (rest11, d) = rest10.getOrElse(pairOfNones)
        val (rest12, c) = rest11.getOrElse(pairOfNones)
        val (a, b) = rest12.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])]) = new FlattenOuterJoin14(nested)

  class FlattenOuterJoin15[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O])] = 
      nested.mapValues { tup =>
        val (rest1, o) = tup
        val (rest2, n) = rest1.getOrElse(pairOfNones)
        val (rest3, m) = rest2.getOrElse(pairOfNones)
        val (rest4, l) = rest3.getOrElse(pairOfNones)
        val (rest5, k) = rest4.getOrElse(pairOfNones)
        val (rest6, j) = rest5.getOrElse(pairOfNones)
        val (rest7, i) = rest6.getOrElse(pairOfNones)
        val (rest8, h) = rest7.getOrElse(pairOfNones)
        val (rest9, g) = rest8.getOrElse(pairOfNones)
        val (rest10, f) = rest9.getOrElse(pairOfNones)
        val (rest11, e) = rest10.getOrElse(pairOfNones)
        val (rest12, d) = rest11.getOrElse(pairOfNones)
        val (rest13, c) = rest12.getOrElse(pairOfNones)
        val (a, b) = rest13.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])]) = new FlattenOuterJoin15(nested)

  class FlattenOuterJoin16[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P])] = 
      nested.mapValues { tup =>
        val (rest1, p) = tup
        val (rest2, o) = rest1.getOrElse(pairOfNones)
        val (rest3, n) = rest2.getOrElse(pairOfNones)
        val (rest4, m) = rest3.getOrElse(pairOfNones)
        val (rest5, l) = rest4.getOrElse(pairOfNones)
        val (rest6, k) = rest5.getOrElse(pairOfNones)
        val (rest7, j) = rest6.getOrElse(pairOfNones)
        val (rest8, i) = rest7.getOrElse(pairOfNones)
        val (rest9, h) = rest8.getOrElse(pairOfNones)
        val (rest10, g) = rest9.getOrElse(pairOfNones)
        val (rest11, f) = rest10.getOrElse(pairOfNones)
        val (rest12, e) = rest11.getOrElse(pairOfNones)
        val (rest13, d) = rest12.getOrElse(pairOfNones)
        val (rest14, c) = rest13.getOrElse(pairOfNones)
        val (a, b) = rest14.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])]) = new FlattenOuterJoin16(nested)

  class FlattenOuterJoin17[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q])] = 
      nested.mapValues { tup =>
        val (rest1, q) = tup
        val (rest2, p) = rest1.getOrElse(pairOfNones)
        val (rest3, o) = rest2.getOrElse(pairOfNones)
        val (rest4, n) = rest3.getOrElse(pairOfNones)
        val (rest5, m) = rest4.getOrElse(pairOfNones)
        val (rest6, l) = rest5.getOrElse(pairOfNones)
        val (rest7, k) = rest6.getOrElse(pairOfNones)
        val (rest8, j) = rest7.getOrElse(pairOfNones)
        val (rest9, i) = rest8.getOrElse(pairOfNones)
        val (rest10, h) = rest9.getOrElse(pairOfNones)
        val (rest11, g) = rest10.getOrElse(pairOfNones)
        val (rest12, f) = rest11.getOrElse(pairOfNones)
        val (rest13, e) = rest12.getOrElse(pairOfNones)
        val (rest14, d) = rest13.getOrElse(pairOfNones)
        val (rest15, c) = rest14.getOrElse(pairOfNones)
        val (a, b) = rest15.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])]) = new FlattenOuterJoin17(nested)

  class FlattenOuterJoin18[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R])] = 
      nested.mapValues { tup =>
        val (rest1, r) = tup
        val (rest2, q) = rest1.getOrElse(pairOfNones)
        val (rest3, p) = rest2.getOrElse(pairOfNones)
        val (rest4, o) = rest3.getOrElse(pairOfNones)
        val (rest5, n) = rest4.getOrElse(pairOfNones)
        val (rest6, m) = rest5.getOrElse(pairOfNones)
        val (rest7, l) = rest6.getOrElse(pairOfNones)
        val (rest8, k) = rest7.getOrElse(pairOfNones)
        val (rest9, j) = rest8.getOrElse(pairOfNones)
        val (rest10, i) = rest9.getOrElse(pairOfNones)
        val (rest11, h) = rest10.getOrElse(pairOfNones)
        val (rest12, g) = rest11.getOrElse(pairOfNones)
        val (rest13, f) = rest12.getOrElse(pairOfNones)
        val (rest14, e) = rest13.getOrElse(pairOfNones)
        val (rest15, d) = rest14.getOrElse(pairOfNones)
        val (rest16, c) = rest15.getOrElse(pairOfNones)
        val (a, b) = rest16.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])]) = new FlattenOuterJoin18(nested)

  class FlattenOuterJoin19[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S])] = 
      nested.mapValues { tup =>
        val (rest1, s) = tup
        val (rest2, r) = rest1.getOrElse(pairOfNones)
        val (rest3, q) = rest2.getOrElse(pairOfNones)
        val (rest4, p) = rest3.getOrElse(pairOfNones)
        val (rest5, o) = rest4.getOrElse(pairOfNones)
        val (rest6, n) = rest5.getOrElse(pairOfNones)
        val (rest7, m) = rest6.getOrElse(pairOfNones)
        val (rest8, l) = rest7.getOrElse(pairOfNones)
        val (rest9, k) = rest8.getOrElse(pairOfNones)
        val (rest10, j) = rest9.getOrElse(pairOfNones)
        val (rest11, i) = rest10.getOrElse(pairOfNones)
        val (rest12, h) = rest11.getOrElse(pairOfNones)
        val (rest13, g) = rest12.getOrElse(pairOfNones)
        val (rest14, f) = rest13.getOrElse(pairOfNones)
        val (rest15, e) = rest14.getOrElse(pairOfNones)
        val (rest16, d) = rest15.getOrElse(pairOfNones)
        val (rest17, c) = rest16.getOrElse(pairOfNones)
        val (a, b) = rest17.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])]) = new FlattenOuterJoin19(nested)

  class FlattenOuterJoin20[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T])] = 
      nested.mapValues { tup =>
        val (rest1, t) = tup
        val (rest2, s) = rest1.getOrElse(pairOfNones)
        val (rest3, r) = rest2.getOrElse(pairOfNones)
        val (rest4, q) = rest3.getOrElse(pairOfNones)
        val (rest5, p) = rest4.getOrElse(pairOfNones)
        val (rest6, o) = rest5.getOrElse(pairOfNones)
        val (rest7, n) = rest6.getOrElse(pairOfNones)
        val (rest8, m) = rest7.getOrElse(pairOfNones)
        val (rest9, l) = rest8.getOrElse(pairOfNones)
        val (rest10, k) = rest9.getOrElse(pairOfNones)
        val (rest11, j) = rest10.getOrElse(pairOfNones)
        val (rest12, i) = rest11.getOrElse(pairOfNones)
        val (rest13, h) = rest12.getOrElse(pairOfNones)
        val (rest14, g) = rest13.getOrElse(pairOfNones)
        val (rest15, f) = rest14.getOrElse(pairOfNones)
        val (rest16, e) = rest15.getOrElse(pairOfNones)
        val (rest17, d) = rest16.getOrElse(pairOfNones)
        val (rest18, c) = rest17.getOrElse(pairOfNones)
        val (a, b) = rest18.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])]) = new FlattenOuterJoin20(nested)

  class FlattenOuterJoin21[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U])] = 
      nested.mapValues { tup =>
        val (rest1, u) = tup
        val (rest2, t) = rest1.getOrElse(pairOfNones)
        val (rest3, s) = rest2.getOrElse(pairOfNones)
        val (rest4, r) = rest3.getOrElse(pairOfNones)
        val (rest5, q) = rest4.getOrElse(pairOfNones)
        val (rest6, p) = rest5.getOrElse(pairOfNones)
        val (rest7, o) = rest6.getOrElse(pairOfNones)
        val (rest8, n) = rest7.getOrElse(pairOfNones)
        val (rest9, m) = rest8.getOrElse(pairOfNones)
        val (rest10, l) = rest9.getOrElse(pairOfNones)
        val (rest11, k) = rest10.getOrElse(pairOfNones)
        val (rest12, j) = rest11.getOrElse(pairOfNones)
        val (rest13, i) = rest12.getOrElse(pairOfNones)
        val (rest14, h) = rest13.getOrElse(pairOfNones)
        val (rest15, g) = rest14.getOrElse(pairOfNones)
        val (rest16, f) = rest15.getOrElse(pairOfNones)
        val (rest17, e) = rest16.getOrElse(pairOfNones)
        val (rest18, d) = rest17.getOrElse(pairOfNones)
        val (rest19, c) = rest18.getOrElse(pairOfNones)
        val (a, b) = rest19.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])]) = new FlattenOuterJoin21(nested)

  class FlattenOuterJoin22[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])], Option[V])]) {
    def flattenGrouped: KLL[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U], Option[V])] = 
      nested.mapValues { tup =>
        val (rest1, v) = tup
        val (rest2, u) = rest1.getOrElse(pairOfNones)
        val (rest3, t) = rest2.getOrElse(pairOfNones)
        val (rest4, s) = rest3.getOrElse(pairOfNones)
        val (rest5, r) = rest4.getOrElse(pairOfNones)
        val (rest6, q) = rest5.getOrElse(pairOfNones)
        val (rest7, p) = rest6.getOrElse(pairOfNones)
        val (rest8, o) = rest7.getOrElse(pairOfNones)
        val (rest9, n) = rest8.getOrElse(pairOfNones)
        val (rest10, m) = rest9.getOrElse(pairOfNones)
        val (rest11, l) = rest10.getOrElse(pairOfNones)
        val (rest12, k) = rest11.getOrElse(pairOfNones)
        val (rest13, j) = rest12.getOrElse(pairOfNones)
        val (rest14, i) = rest13.getOrElse(pairOfNones)
        val (rest15, h) = rest14.getOrElse(pairOfNones)
        val (rest16, g) = rest15.getOrElse(pairOfNones)
        val (rest17, f) = rest16.getOrElse(pairOfNones)
        val (rest18, e) = rest17.getOrElse(pairOfNones)
        val (rest19, d) = rest18.getOrElse(pairOfNones)
        val (rest20, c) = rest19.getOrElse(pairOfNones)
        val (a, b) = rest20.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
      }
  }

  def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: KLL[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])], Option[V])]) = new FlattenOuterJoin22(nested)

}
// end of autogenerated
