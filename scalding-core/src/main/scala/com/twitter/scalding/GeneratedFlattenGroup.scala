// following were autogenerated by ./codegen/flatten_group_generator.rb at Wed Nov 19 00:08:51 -0800 2014 do not edit
package com.twitter.scalding

import com.twitter.scalding.typed.CoGrouped

object FlattenGroup {
  val pairOfNones = (None, None)

  implicit class FlattenLeftJoin3[KEY, A, B, C](nested: CoGrouped[KEY, ((A, B), C)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C)] = {
      nested.mapValues { tup =>
        val ((a, b), c) = tup
        (a, b, c)
      }
    }
  }

  implicit class FlattenLeftJoin4[KEY, A, B, C, D](nested: CoGrouped[KEY, (((A, B), C), D)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D)] = {
      nested.mapValues { tup =>
        val (((a, b), c), d) = tup
        (a, b, c, d)
      }
    }
  }

  implicit class FlattenLeftJoin5[KEY, A, B, C, D, E](nested: CoGrouped[KEY, ((((A, B), C), D), E)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E)] = {
      nested.mapValues { tup =>
        val ((((a, b), c), d), e) = tup
        (a, b, c, d, e)
      }
    }
  }

  implicit class FlattenLeftJoin6[KEY, A, B, C, D, E, F](nested: CoGrouped[KEY, (((((A, B), C), D), E), F)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F)] = {
      nested.mapValues { tup =>
        val (((((a, b), c), d), e), f) = tup
        (a, b, c, d, e, f)
      }
    }
  }

  implicit class FlattenLeftJoin7[KEY, A, B, C, D, E, F, G](nested: CoGrouped[KEY, ((((((A, B), C), D), E), F), G)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G)] = {
      nested.mapValues { tup =>
        val ((((((a, b), c), d), e), f), g) = tup
        (a, b, c, d, e, f, g)
      }
    }
  }

  implicit class FlattenLeftJoin8[KEY, A, B, C, D, E, F, G, H](nested: CoGrouped[KEY, (((((((A, B), C), D), E), F), G), H)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H)] = {
      nested.mapValues { tup =>
        val (((((((a, b), c), d), e), f), g), h) = tup
        (a, b, c, d, e, f, g, h)
      }
    }
  }

  implicit class FlattenLeftJoin9[KEY, A, B, C, D, E, F, G, H, I](nested: CoGrouped[KEY, ((((((((A, B), C), D), E), F), G), H), I)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I)] = {
      nested.mapValues { tup =>
        val ((((((((a, b), c), d), e), f), g), h), i) = tup
        (a, b, c, d, e, f, g, h, i)
      }
    }
  }

  implicit class FlattenLeftJoin10[KEY, A, B, C, D, E, F, G, H, I, J](nested: CoGrouped[KEY, (((((((((A, B), C), D), E), F), G), H), I), J)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J)] = {
      nested.mapValues { tup =>
        val (((((((((a, b), c), d), e), f), g), h), i), j) = tup
        (a, b, c, d, e, f, g, h, i, j)
      }
    }
  }

  implicit class FlattenLeftJoin11[KEY, A, B, C, D, E, F, G, H, I, J, K](nested: CoGrouped[KEY, ((((((((((A, B), C), D), E), F), G), H), I), J), K)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K)] = {
      nested.mapValues { tup =>
        val ((((((((((a, b), c), d), e), f), g), h), i), j), k) = tup
        (a, b, c, d, e, f, g, h, i, j, k)
      }
    }
  }

  implicit class FlattenLeftJoin12[KEY, A, B, C, D, E, F, G, H, I, J, K, L](nested: CoGrouped[KEY, (((((((((((A, B), C), D), E), F), G), H), I), J), K), L)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L)] = {
      nested.mapValues { tup =>
        val (((((((((((a, b), c), d), e), f), g), h), i), j), k), l) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l)
      }
    }
  }

  implicit class FlattenLeftJoin13[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M](nested: CoGrouped[KEY, ((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M)] = {
      nested.mapValues { tup =>
        val ((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m)
      }
    }
  }

  implicit class FlattenLeftJoin14[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: CoGrouped[KEY, (((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N)] = {
      nested.mapValues { tup =>
        val (((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
      }
    }
  }

  implicit class FlattenLeftJoin15[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: CoGrouped[KEY, ((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] = {
      nested.mapValues { tup =>
        val ((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
      }
    }
  }

  implicit class FlattenLeftJoin16[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: CoGrouped[KEY, (((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] = {
      nested.mapValues { tup =>
        val (((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
      }
    }
  }

  implicit class FlattenLeftJoin17[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: CoGrouped[KEY, ((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] = {
      nested.mapValues { tup =>
        val ((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
      }
    }
  }

  implicit class FlattenLeftJoin18[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: CoGrouped[KEY, (((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] = {
      nested.mapValues { tup =>
        val (((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
      }
    }
  }

  implicit class FlattenLeftJoin19[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: CoGrouped[KEY, ((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] = {
      nested.mapValues { tup =>
        val ((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
      }
    }
  }

  implicit class FlattenLeftJoin20[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: CoGrouped[KEY, (((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] = {
      nested.mapValues { tup =>
        val (((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
      }
    }
  }

  implicit class FlattenLeftJoin21[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: CoGrouped[KEY, ((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] = {
      nested.mapValues { tup =>
        val ((((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t), u) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
      }
    }
  }

  implicit class FlattenLeftJoin22[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: CoGrouped[KEY, (((((((((((((((((((((A, B), C), D), E), F), G), H), I), J), K), L), M), N), O), P), Q), R), S), T), U), V)]) {
    def flattenGrouped: CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] = {
      nested.mapValues { tup =>
        val (((((((((((((((((((((a, b), c), d), e), f), g), h), i), j), k), l), m), n), o), p), q), r), s), t), u), v) = tup
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
      }
    }
  }

  implicit class FlattenOuterJoin3[KEY, A, B, C](nested: CoGrouped[KEY, (Option[(Option[A], Option[B])], Option[C])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C])] = {
      nested.mapValues { tup =>
        val (rest1, c) = tup
        val (a, b) = rest1.getOrElse(pairOfNones)
        (a, b, c)
      }
    }
  }

  implicit class FlattenOuterJoin4[KEY, A, B, C, D](nested: CoGrouped[KEY, (Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D])] = {
      nested.mapValues { tup =>
        val (rest1, d) = tup
        val (rest2, c) = rest1.getOrElse(pairOfNones)
        val (a, b) = rest2.getOrElse(pairOfNones)
        (a, b, c, d)
      }
    }
  }

  implicit class FlattenOuterJoin5[KEY, A, B, C, D, E](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E])] = {
      nested.mapValues { tup =>
        val (rest1, e) = tup
        val (rest2, d) = rest1.getOrElse(pairOfNones)
        val (rest3, c) = rest2.getOrElse(pairOfNones)
        val (a, b) = rest3.getOrElse(pairOfNones)
        (a, b, c, d, e)
      }
    }
  }

  implicit class FlattenOuterJoin6[KEY, A, B, C, D, E, F](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F])] = {
      nested.mapValues { tup =>
        val (rest1, f) = tup
        val (rest2, e) = rest1.getOrElse(pairOfNones)
        val (rest3, d) = rest2.getOrElse(pairOfNones)
        val (rest4, c) = rest3.getOrElse(pairOfNones)
        val (a, b) = rest4.getOrElse(pairOfNones)
        (a, b, c, d, e, f)
      }
    }
  }

  implicit class FlattenOuterJoin7[KEY, A, B, C, D, E, F, G](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G])] = {
      nested.mapValues { tup =>
        val (rest1, g) = tup
        val (rest2, f) = rest1.getOrElse(pairOfNones)
        val (rest3, e) = rest2.getOrElse(pairOfNones)
        val (rest4, d) = rest3.getOrElse(pairOfNones)
        val (rest5, c) = rest4.getOrElse(pairOfNones)
        val (a, b) = rest5.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g)
      }
    }
  }

  implicit class FlattenOuterJoin8[KEY, A, B, C, D, E, F, G, H](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H])] = {
      nested.mapValues { tup =>
        val (rest1, h) = tup
        val (rest2, g) = rest1.getOrElse(pairOfNones)
        val (rest3, f) = rest2.getOrElse(pairOfNones)
        val (rest4, e) = rest3.getOrElse(pairOfNones)
        val (rest5, d) = rest4.getOrElse(pairOfNones)
        val (rest6, c) = rest5.getOrElse(pairOfNones)
        val (a, b) = rest6.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h)
      }
    }
  }

  implicit class FlattenOuterJoin9[KEY, A, B, C, D, E, F, G, H, I](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I])] = {
      nested.mapValues { tup =>
        val (rest1, i) = tup
        val (rest2, h) = rest1.getOrElse(pairOfNones)
        val (rest3, g) = rest2.getOrElse(pairOfNones)
        val (rest4, f) = rest3.getOrElse(pairOfNones)
        val (rest5, e) = rest4.getOrElse(pairOfNones)
        val (rest6, d) = rest5.getOrElse(pairOfNones)
        val (rest7, c) = rest6.getOrElse(pairOfNones)
        val (a, b) = rest7.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i)
      }
    }
  }

  implicit class FlattenOuterJoin10[KEY, A, B, C, D, E, F, G, H, I, J](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J])] = {
      nested.mapValues { tup =>
        val (rest1, j) = tup
        val (rest2, i) = rest1.getOrElse(pairOfNones)
        val (rest3, h) = rest2.getOrElse(pairOfNones)
        val (rest4, g) = rest3.getOrElse(pairOfNones)
        val (rest5, f) = rest4.getOrElse(pairOfNones)
        val (rest6, e) = rest5.getOrElse(pairOfNones)
        val (rest7, d) = rest6.getOrElse(pairOfNones)
        val (rest8, c) = rest7.getOrElse(pairOfNones)
        val (a, b) = rest8.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j)
      }
    }
  }

  implicit class FlattenOuterJoin11[KEY, A, B, C, D, E, F, G, H, I, J, K](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K])] = {
      nested.mapValues { tup =>
        val (rest1, k) = tup
        val (rest2, j) = rest1.getOrElse(pairOfNones)
        val (rest3, i) = rest2.getOrElse(pairOfNones)
        val (rest4, h) = rest3.getOrElse(pairOfNones)
        val (rest5, g) = rest4.getOrElse(pairOfNones)
        val (rest6, f) = rest5.getOrElse(pairOfNones)
        val (rest7, e) = rest6.getOrElse(pairOfNones)
        val (rest8, d) = rest7.getOrElse(pairOfNones)
        val (rest9, c) = rest8.getOrElse(pairOfNones)
        val (a, b) = rest9.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k)
      }
    }
  }

  implicit class FlattenOuterJoin12[KEY, A, B, C, D, E, F, G, H, I, J, K, L](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L])] = {
      nested.mapValues { tup =>
        val (rest1, l) = tup
        val (rest2, k) = rest1.getOrElse(pairOfNones)
        val (rest3, j) = rest2.getOrElse(pairOfNones)
        val (rest4, i) = rest3.getOrElse(pairOfNones)
        val (rest5, h) = rest4.getOrElse(pairOfNones)
        val (rest6, g) = rest5.getOrElse(pairOfNones)
        val (rest7, f) = rest6.getOrElse(pairOfNones)
        val (rest8, e) = rest7.getOrElse(pairOfNones)
        val (rest9, d) = rest8.getOrElse(pairOfNones)
        val (rest10, c) = rest9.getOrElse(pairOfNones)
        val (a, b) = rest10.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l)
      }
    }
  }

  implicit class FlattenOuterJoin13[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M])] = {
      nested.mapValues { tup =>
        val (rest1, m) = tup
        val (rest2, l) = rest1.getOrElse(pairOfNones)
        val (rest3, k) = rest2.getOrElse(pairOfNones)
        val (rest4, j) = rest3.getOrElse(pairOfNones)
        val (rest5, i) = rest4.getOrElse(pairOfNones)
        val (rest6, h) = rest5.getOrElse(pairOfNones)
        val (rest7, g) = rest6.getOrElse(pairOfNones)
        val (rest8, f) = rest7.getOrElse(pairOfNones)
        val (rest9, e) = rest8.getOrElse(pairOfNones)
        val (rest10, d) = rest9.getOrElse(pairOfNones)
        val (rest11, c) = rest10.getOrElse(pairOfNones)
        val (a, b) = rest11.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m)
      }
    }
  }

  implicit class FlattenOuterJoin14[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N])] = {
      nested.mapValues { tup =>
        val (rest1, n) = tup
        val (rest2, m) = rest1.getOrElse(pairOfNones)
        val (rest3, l) = rest2.getOrElse(pairOfNones)
        val (rest4, k) = rest3.getOrElse(pairOfNones)
        val (rest5, j) = rest4.getOrElse(pairOfNones)
        val (rest6, i) = rest5.getOrElse(pairOfNones)
        val (rest7, h) = rest6.getOrElse(pairOfNones)
        val (rest8, g) = rest7.getOrElse(pairOfNones)
        val (rest9, f) = rest8.getOrElse(pairOfNones)
        val (rest10, e) = rest9.getOrElse(pairOfNones)
        val (rest11, d) = rest10.getOrElse(pairOfNones)
        val (rest12, c) = rest11.getOrElse(pairOfNones)
        val (a, b) = rest12.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
      }
    }
  }

  implicit class FlattenOuterJoin15[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O])] = {
      nested.mapValues { tup =>
        val (rest1, o) = tup
        val (rest2, n) = rest1.getOrElse(pairOfNones)
        val (rest3, m) = rest2.getOrElse(pairOfNones)
        val (rest4, l) = rest3.getOrElse(pairOfNones)
        val (rest5, k) = rest4.getOrElse(pairOfNones)
        val (rest6, j) = rest5.getOrElse(pairOfNones)
        val (rest7, i) = rest6.getOrElse(pairOfNones)
        val (rest8, h) = rest7.getOrElse(pairOfNones)
        val (rest9, g) = rest8.getOrElse(pairOfNones)
        val (rest10, f) = rest9.getOrElse(pairOfNones)
        val (rest11, e) = rest10.getOrElse(pairOfNones)
        val (rest12, d) = rest11.getOrElse(pairOfNones)
        val (rest13, c) = rest12.getOrElse(pairOfNones)
        val (a, b) = rest13.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
      }
    }
  }

  implicit class FlattenOuterJoin16[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P])] = {
      nested.mapValues { tup =>
        val (rest1, p) = tup
        val (rest2, o) = rest1.getOrElse(pairOfNones)
        val (rest3, n) = rest2.getOrElse(pairOfNones)
        val (rest4, m) = rest3.getOrElse(pairOfNones)
        val (rest5, l) = rest4.getOrElse(pairOfNones)
        val (rest6, k) = rest5.getOrElse(pairOfNones)
        val (rest7, j) = rest6.getOrElse(pairOfNones)
        val (rest8, i) = rest7.getOrElse(pairOfNones)
        val (rest9, h) = rest8.getOrElse(pairOfNones)
        val (rest10, g) = rest9.getOrElse(pairOfNones)
        val (rest11, f) = rest10.getOrElse(pairOfNones)
        val (rest12, e) = rest11.getOrElse(pairOfNones)
        val (rest13, d) = rest12.getOrElse(pairOfNones)
        val (rest14, c) = rest13.getOrElse(pairOfNones)
        val (a, b) = rest14.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
      }
    }
  }

  implicit class FlattenOuterJoin17[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q])] = {
      nested.mapValues { tup =>
        val (rest1, q) = tup
        val (rest2, p) = rest1.getOrElse(pairOfNones)
        val (rest3, o) = rest2.getOrElse(pairOfNones)
        val (rest4, n) = rest3.getOrElse(pairOfNones)
        val (rest5, m) = rest4.getOrElse(pairOfNones)
        val (rest6, l) = rest5.getOrElse(pairOfNones)
        val (rest7, k) = rest6.getOrElse(pairOfNones)
        val (rest8, j) = rest7.getOrElse(pairOfNones)
        val (rest9, i) = rest8.getOrElse(pairOfNones)
        val (rest10, h) = rest9.getOrElse(pairOfNones)
        val (rest11, g) = rest10.getOrElse(pairOfNones)
        val (rest12, f) = rest11.getOrElse(pairOfNones)
        val (rest13, e) = rest12.getOrElse(pairOfNones)
        val (rest14, d) = rest13.getOrElse(pairOfNones)
        val (rest15, c) = rest14.getOrElse(pairOfNones)
        val (a, b) = rest15.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
      }
    }
  }

  implicit class FlattenOuterJoin18[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R])] = {
      nested.mapValues { tup =>
        val (rest1, r) = tup
        val (rest2, q) = rest1.getOrElse(pairOfNones)
        val (rest3, p) = rest2.getOrElse(pairOfNones)
        val (rest4, o) = rest3.getOrElse(pairOfNones)
        val (rest5, n) = rest4.getOrElse(pairOfNones)
        val (rest6, m) = rest5.getOrElse(pairOfNones)
        val (rest7, l) = rest6.getOrElse(pairOfNones)
        val (rest8, k) = rest7.getOrElse(pairOfNones)
        val (rest9, j) = rest8.getOrElse(pairOfNones)
        val (rest10, i) = rest9.getOrElse(pairOfNones)
        val (rest11, h) = rest10.getOrElse(pairOfNones)
        val (rest12, g) = rest11.getOrElse(pairOfNones)
        val (rest13, f) = rest12.getOrElse(pairOfNones)
        val (rest14, e) = rest13.getOrElse(pairOfNones)
        val (rest15, d) = rest14.getOrElse(pairOfNones)
        val (rest16, c) = rest15.getOrElse(pairOfNones)
        val (a, b) = rest16.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
      }
    }
  }

  implicit class FlattenOuterJoin19[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S])] = {
      nested.mapValues { tup =>
        val (rest1, s) = tup
        val (rest2, r) = rest1.getOrElse(pairOfNones)
        val (rest3, q) = rest2.getOrElse(pairOfNones)
        val (rest4, p) = rest3.getOrElse(pairOfNones)
        val (rest5, o) = rest4.getOrElse(pairOfNones)
        val (rest6, n) = rest5.getOrElse(pairOfNones)
        val (rest7, m) = rest6.getOrElse(pairOfNones)
        val (rest8, l) = rest7.getOrElse(pairOfNones)
        val (rest9, k) = rest8.getOrElse(pairOfNones)
        val (rest10, j) = rest9.getOrElse(pairOfNones)
        val (rest11, i) = rest10.getOrElse(pairOfNones)
        val (rest12, h) = rest11.getOrElse(pairOfNones)
        val (rest13, g) = rest12.getOrElse(pairOfNones)
        val (rest14, f) = rest13.getOrElse(pairOfNones)
        val (rest15, e) = rest14.getOrElse(pairOfNones)
        val (rest16, d) = rest15.getOrElse(pairOfNones)
        val (rest17, c) = rest16.getOrElse(pairOfNones)
        val (a, b) = rest17.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
      }
    }
  }

  implicit class FlattenOuterJoin20[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T])] = {
      nested.mapValues { tup =>
        val (rest1, t) = tup
        val (rest2, s) = rest1.getOrElse(pairOfNones)
        val (rest3, r) = rest2.getOrElse(pairOfNones)
        val (rest4, q) = rest3.getOrElse(pairOfNones)
        val (rest5, p) = rest4.getOrElse(pairOfNones)
        val (rest6, o) = rest5.getOrElse(pairOfNones)
        val (rest7, n) = rest6.getOrElse(pairOfNones)
        val (rest8, m) = rest7.getOrElse(pairOfNones)
        val (rest9, l) = rest8.getOrElse(pairOfNones)
        val (rest10, k) = rest9.getOrElse(pairOfNones)
        val (rest11, j) = rest10.getOrElse(pairOfNones)
        val (rest12, i) = rest11.getOrElse(pairOfNones)
        val (rest13, h) = rest12.getOrElse(pairOfNones)
        val (rest14, g) = rest13.getOrElse(pairOfNones)
        val (rest15, f) = rest14.getOrElse(pairOfNones)
        val (rest16, e) = rest15.getOrElse(pairOfNones)
        val (rest17, d) = rest16.getOrElse(pairOfNones)
        val (rest18, c) = rest17.getOrElse(pairOfNones)
        val (a, b) = rest18.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
      }
    }
  }

  implicit class FlattenOuterJoin21[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U])] = {
      nested.mapValues { tup =>
        val (rest1, u) = tup
        val (rest2, t) = rest1.getOrElse(pairOfNones)
        val (rest3, s) = rest2.getOrElse(pairOfNones)
        val (rest4, r) = rest3.getOrElse(pairOfNones)
        val (rest5, q) = rest4.getOrElse(pairOfNones)
        val (rest6, p) = rest5.getOrElse(pairOfNones)
        val (rest7, o) = rest6.getOrElse(pairOfNones)
        val (rest8, n) = rest7.getOrElse(pairOfNones)
        val (rest9, m) = rest8.getOrElse(pairOfNones)
        val (rest10, l) = rest9.getOrElse(pairOfNones)
        val (rest11, k) = rest10.getOrElse(pairOfNones)
        val (rest12, j) = rest11.getOrElse(pairOfNones)
        val (rest13, i) = rest12.getOrElse(pairOfNones)
        val (rest14, h) = rest13.getOrElse(pairOfNones)
        val (rest15, g) = rest14.getOrElse(pairOfNones)
        val (rest16, f) = rest15.getOrElse(pairOfNones)
        val (rest17, e) = rest16.getOrElse(pairOfNones)
        val (rest18, d) = rest17.getOrElse(pairOfNones)
        val (rest19, c) = rest18.getOrElse(pairOfNones)
        val (a, b) = rest19.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
      }
    }
  }

  implicit class FlattenOuterJoin22[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](nested: CoGrouped[KEY, (Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[(Option[A], Option[B])], Option[C])], Option[D])], Option[E])], Option[F])], Option[G])], Option[H])], Option[I])], Option[J])], Option[K])], Option[L])], Option[M])], Option[N])], Option[O])], Option[P])], Option[Q])], Option[R])], Option[S])], Option[T])], Option[U])], Option[V])]) {
    def flattenGrouped: CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U], Option[V])] = {
      nested.mapValues { tup =>
        val (rest1, v) = tup
        val (rest2, u) = rest1.getOrElse(pairOfNones)
        val (rest3, t) = rest2.getOrElse(pairOfNones)
        val (rest4, s) = rest3.getOrElse(pairOfNones)
        val (rest5, r) = rest4.getOrElse(pairOfNones)
        val (rest6, q) = rest5.getOrElse(pairOfNones)
        val (rest7, p) = rest6.getOrElse(pairOfNones)
        val (rest8, o) = rest7.getOrElse(pairOfNones)
        val (rest9, n) = rest8.getOrElse(pairOfNones)
        val (rest10, m) = rest9.getOrElse(pairOfNones)
        val (rest11, l) = rest10.getOrElse(pairOfNones)
        val (rest12, k) = rest11.getOrElse(pairOfNones)
        val (rest13, j) = rest12.getOrElse(pairOfNones)
        val (rest14, i) = rest13.getOrElse(pairOfNones)
        val (rest15, h) = rest14.getOrElse(pairOfNones)
        val (rest16, g) = rest15.getOrElse(pairOfNones)
        val (rest17, f) = rest16.getOrElse(pairOfNones)
        val (rest18, e) = rest17.getOrElse(pairOfNones)
        val (rest19, d) = rest18.getOrElse(pairOfNones)
        val (rest20, c) = rest19.getOrElse(pairOfNones)
        val (a, b) = rest20.getOrElse(pairOfNones)
        (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
      }
    }
  }

}
// end of autogenerated
