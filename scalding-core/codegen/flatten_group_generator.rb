#!/usr/bin/env ruby

# Run it like this:
#
#   ./codegen/flatten_group_generator.rb > src/main/scala/com/twitter/scalding/GeneratedFlattenGroup.scala

$indent = "  "

TYPES = ('A'..'Z').to_a

def make_nested_type(arity)
  if arity < 2 
    raise "arity < 2 doesn't make sense here"
  end
    
  if arity == 2 
    return "(#{TYPES[0]}, #{TYPES[1]})"
  else
    prev = make_nested_type(arity - 1)
    return "(#{prev}, #{TYPES[arity - 1]})"
  end
end

def make_flatten_left_join(arity)
  nested_type = make_nested_type(arity)
  flat_type = TYPES[0..(arity - 1)].join(", ")
  
  puts "#{$indent}class FlattenLeftJoin#{arity}[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], #{flat_type}](nested: KLL[KEY, #{nested_type}]) {"
  puts "#{$indent*2}def flattenGrouped: KLL[KEY, (#{flat_type})] = "
  puts "#{$indent*3}nested.mapValues { tup =>"
  puts "#{$indent*4}val #{nested_type.downcase} = tup"
  puts "#{$indent*4}(#{flat_type.downcase})"
  puts "#{$indent*3}}"
  puts "#{$indent}}"
  puts
  puts "#{$indent}implicit def toFlattenLeftJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], #{flat_type}](nested: KLL[KEY, #{nested_type}]) = new FlattenLeftJoin#{arity}(nested)"
end

def make_alternating_nested_type(arity)
  if arity < 2 
    raise "arity < 2 doesn't make sense here"
  end
    
  if arity == 2 
    return "(Option[#{TYPES[0]}], Option[#{TYPES[1]}])"
  else
    prev = make_alternating_nested_type(arity - 1)
    return "(Option[#{prev}], Option[#{TYPES[arity - 1]}])"
  end
end

def make_flatten_outer_join(arity)
  nested_type = make_alternating_nested_type(arity)
  types = TYPES[0..(arity - 1)]
  flat_type = types.join(", ")
  flat_type_options = types.map {|x| "Option[#{x}]"}.join(", ")
  
  puts "#{$indent}class FlattenOuterJoin#{arity}[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], #{flat_type}](nested: KLL[KEY, #{nested_type}]) {"
  puts "#{$indent*2}def flattenGrouped: KLL[KEY, (#{flat_type_options})] = "
  puts "#{$indent*3}nested.mapValues { tup =>"
  
  puts "#{$indent*4}val (rest1, #{TYPES[arity-1].downcase}) = tup"

  (1..(arity-3)).each do |n|
    puts "#{$indent*4}val (rest#{n+1}, #{TYPES[arity-1-n].downcase}) = rest#{n}.getOrElse(pairOfNones)"
  end
  
  puts "#{$indent*4}val (#{TYPES[0].downcase}, #{TYPES[1].downcase}) = rest#{arity-2}.getOrElse(pairOfNones)"
  
  puts "#{$indent*4}(#{flat_type.downcase})"
  
  puts "#{$indent*3}}"
  puts "#{$indent}}"
  puts
  puts "#{$indent}def toFlattenOuterJoin[KEY, KLL[KLL_K, +KLL_V] <: KeyedListLike[KLL_K, KLL_V, KLL], #{flat_type}](nested: KLL[KEY, #{nested_type}]) = new FlattenOuterJoin#{arity}(nested)"
end

puts "// following were autogenerated by #{__FILE__} at #{Time.now} do not edit"
puts %q|package com.twitter.scalding

import com.twitter.scalding.typed.KeyedListLike

object FlattenGroup {
  val pairOfNones = (None, None)

|

(3..22).each { |a|
  make_flatten_left_join(a)
  puts
}

(3..22).each { |a|
  make_flatten_outer_join(a)
  puts
}


puts "}"

puts "// end of autogenerated"
